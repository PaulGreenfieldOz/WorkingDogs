using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Diagnostics;
using WorkingDogsCore;

namespace FilterReads
{
    class Program
    {
        // Filters a set of read against any number of filters. The filters can be inclusive (such as 16S)
        // or exclusive (such as human 18S). Filters are sets of tiles generated by GenerateMerFilter.
        //
        // usage: FilterReads -r tag -t threads [-pairs] [-matches] [-full] [-len minLen] [-wanted nnnn] [-s] [-qt minQual] [-o outputDir] [-fasta] [-discards] [+/-lcf] [+f|fz includeFilter minMatches[%]] [-f|fz excludeFilter minMatches[%|pct]] readsFNs
        //
        // -r 16S -t 8 +f current_prokMSA_unaligned_May2011_25.mer 10% -f Human_mitochondria_25.mer 20% -f human_18S_25.mer 20% GH_02d_ATCACG_R?.fastq
        // -r aflatoxin  Contigs\F36-HGM-57\contigs_F36-HGM-57-11.fa -t 16 +f aflatoxinGenes_25.mer 1000
        // -r perurans -t 24 -eitherinpair -full -qt 25 +fz perurans_draft_25.mer 90pct I:\Amoeba\PCRFree\11957_C9F15ANXX_CGATGTTT_L005_R?.fastq.gz

        static long progressReadsRead = 0;
        static long progressReadsAccepted = 0;
        static long progressReadsRejected = 0;
        static long kMersChecked = 0;
        static long kMersPassedSeedCheck = 0;
        static long kMersVariantsTried = 0;
        static long kMerVariantsFound = 0;
        static long kMersNotMatchedAlready = 0;
        static long kMersMatchedAlready = 0;
        static int ranCleanUnmatched = 0;
        static bool stopReporter = false;
        static ManualResetEvent signalReporter = new ManualResetEvent(false);
        static int reportInterval = 60000;
        static StreamWriter matches = null;
        static bool saveMatches = false;
        static bool recursiveSearch = false;
        static string outputDir = null;
        static bool pairedReads = false;
        static bool matchBothInPair = false;
        static bool matchEitherInPair = false;
        static bool lowComplexityFilter = false;
        static bool qualTrim = false;
        static int minQual = 0;
        static bool fullLength = false;
        //static bool tracing = false;
        static bool saveDiscards = false;
        static int acceptedReadsWanted = 0;

        //static StreamWriter rejects = null;

        enum FilterType { IncFilter, ExcFilter };

        const int maxReadSize = 1000;
        const int batchSize = 1000;
        const int defaultReadLength = 300;
        const int defaultHeaderLength = 50;
        const int lcSize = 3;                                    // size of small kMer used in low-complexity filter
        static int kMerSeedSize = 13;                            // size of kMer seeds that must match before we try for a more expensive full fuzzy match
        static ulong seedMask = 0xFFFFFFFFFFFFFFFF << (64 - kMerSeedSize * 2); // and a mask to extract the seed from the top of a kMer
        const int unmatchedLength = 1000000;                     // initial size of unmatched dictionaries
        const int smallFilterSize = 50000;                       // all variants generated for small filters, not just seeds

        static void Main(string[] args)
        {
            if (args.Length == 0)
            {
                WriteUsage();
                return;
            }

            string runName = "filtered";
            List<string> readsPatterns = new List<string>();
            int threads = 1;
            int minLen = 0;
            int outputFormat = SeqFiles.formatNone;
            int qualOffset = 0;

            List<string> incFilterNames = new List<string>(5);
            List<int> incFilterMins = new List<int>(5);
            List<bool> incFilterPct = new List<bool>(5);
            List<bool> incFilterIsFuzzy = new List<bool>(5);
            List<string> excFilterNames = new List<string>(5);
            List<int> excFilterMins = new List<int>(5);
            List<bool> excFilterPct = new List<bool>(5);
            List<bool> excFilterIsFuzzy = new List<bool>(5);

            for (int p = 0; p < args.Length; p++)
            {
                if (args[p][0] == '-' || args[p][0] == '+')
                {
                    args[p] = args[p].ToLower();

                    if (args[p] == "-h" || args[p] == "-help")
                    {
                        WriteUsage();
                        return;
                    }

                    if (args[p] == "-lcf")
                    {
                        lowComplexityFilter = true;
                        continue;
                    }

                    if (args[p] == "-fasta")
                    {
                        outputFormat = SeqFiles.formatFNA;
                        continue;
                    }

                    if (args[p] == "-full" || args[p] == "-fulllength")
                    {
                        fullLength = true;
                        continue;
                    }

                    if (args[p] == "-pairs" || args[p] == "-bothinpair" || args[p] == "-bip")
                    {
                        pairedReads = true;
                        matchBothInPair = true;
                        continue;
                    }

                    if (args[p] == "-eitherinpair" || args[p] == "-eip")
                    {
                        pairedReads = true;
                        matchEitherInPair = true;
                        continue;
                    }

                    if (args[p] == "-m" || args[p] == "-matches")
                    {
                        saveMatches = true;
                        continue;
                    }

                    if (args[p] == "-s")
                    {
                        recursiveSearch = true;
                        continue;
                    }

                    if (args[p] == "-d" || args[p] == "-discards")
                    {
                        saveDiscards = true;
                        continue;
                    }

                    if (args[p] == "-qualtrim" || args[p] == "-qt" || args[p] == "-tq" || args[p] == "-trimqual")
                    {
                        if (!CheckForParamValue(p, args.Length, "number expected after -qt|-qualTrim"))
                            return;
                        try
                        {
                            minQual = Convert.ToInt32(args[p + 1]);
                        }
                        catch
                        {
                            Console.WriteLine("expected a number after -qt|-qualTrim: " + args[p + 1]);
                            return;
                        }
                        qualTrim = true;
                        p++;
                        continue;
                    }

                    if (args[p] == "-r" || args[p] == "-run")
                    {
                        if (!CheckForParamValue(p, args.Length, "run name string expected after -r|-run"))
                            return;
                        runName = args[p + 1];
                        p++;
                        continue;
                    }

                    if (args[p] == "-o")
                    {
                        if (!CheckForParamValue(p, args.Length, "output directory expected after -o"))
                            return;
                        outputDir = args[p + 1];
                        p++;
                        continue;
                    }

                    if (args[p] == "-t" || args[p] == "-threads")
                    {
                        if (!CheckForParamValue(p, args.Length, "number expected after -t|-threads"))
                            return;
                        try
                        {
                            threads = Convert.ToInt32(args[p + 1]);
                        }
                        catch
                        {
                            Console.WriteLine("expected a number after the -t|-threads parameter: " + args[p + 1]);
                            return;
                        }
                        p++;
                        continue;
                    }

                    if (args[p] == "-wanted" || args[p] == "-first")
                    {
                        if (!CheckForParamValue(p, args.Length, "number expected after -wanted"))
                            return;
                        try
                        {
                            acceptedReadsWanted = Convert.ToInt32(args[p + 1]);
                        }
                        catch
                        {
                            Console.WriteLine("expected a number after the -wanted parameter: " + args[p + 1]);
                            return;
                        }
                        p++;
                        continue;
                    }

                    if (args[p] == "-sl" || args[p] == "-seedlength")
                    {
                        if (!CheckForParamValue(p, args.Length, "number expected after -seedlength"))
                            return;
                        try
                        {
                            kMerSeedSize = Convert.ToInt32(args[p + 1]);
                        }
                        catch
                        {
                            Console.WriteLine("expected a number after the -seedlength parameter: " + args[p + 1]);
                            return;
                        }
                        if (kMerSeedSize > 32)
                        {
                            Console.WriteLine("seed must be smaller than a kMer: " + kMerSeedSize);
                            return;
                        }
                        seedMask = 0xFFFFFFFFFFFFFFFF << (64 - kMerSeedSize * 2);
                        p++;
                        continue;
                    }

                    if (args[p] == "-l" || args[p] == "-len")
                    {
                        if (!CheckForParamValue(p, args.Length, "number expected after -l|-length"))
                            return;
                        try
                        {
                            minLen = Convert.ToInt32(args[p + 1]);
                        }
                        catch
                        {
                            Console.WriteLine("expected a number after the -l|-len parameter: " + args[p + 1]);
                            return;
                        }
                        p++;
                        continue;
                    }

                    if (args[p] == "-f" || args[p] == "-filter" || args[p] == "-fz" || args[p] == "-fuzzyfilter")
                    {
                        if (!CheckForParamValue(p, args.Length, "filter file name string expected after -f|-filter|-fz|-fuzzyfilter"))
                            return;
                        excFilterNames.Add(args[p + 1]);
                        try
                        {
                            string matchPCT = args[p + 2];
                            bool pctFound = false;
                            if (matchPCT.EndsWith("%") || matchPCT.EndsWith("pct"))
                            {
                                matchPCT = matchPCT.Replace('%', ' ');
                                matchPCT = matchPCT.Replace("pct", "");
                                matchPCT = matchPCT.Trim();
                                pctFound = true;
                            }
                            int minCount = Convert.ToInt32(matchPCT);
                            excFilterMins.Add(minCount);
                            excFilterPct.Add(pctFound);
                            if (pctFound && (minCount < 0 || minCount > 100))
                            {
                                Console.WriteLine("-f filter percentage must be between 0 and 100: " + minCount);
                                return;
                            }
                            if (args[p] == "-f" || args[p] == "-filter")
                                excFilterIsFuzzy.Add(false);
                            else
                                excFilterIsFuzzy.Add(true);
                        }
                        catch
                        {
                            Console.WriteLine("expected a number or percentage after the filter name: " + args[p + 2]);
                            return;
                        }
                        p += 2;
                        continue;
                    }

                    if (args[p] == "+f" || args[p] == "+filter" || args[p] == "+fz" || args[p] == "+fuzzyfilter")
                    {
                        if (!CheckForParamValue(p, args.Length, "filter file name string expected after +f|+filter|+fz|+fuzzyfilter"))
                            return;
                        incFilterNames.Add(args[p + 1]);
                        try
                        {
                            string matchPCT = args[p + 2];
                            bool pctFound = false;
                            if (matchPCT.EndsWith("%") || matchPCT.EndsWith("pct"))
                            {
                                matchPCT = matchPCT.Replace('%', ' ');
                                matchPCT = matchPCT.Replace("pct", "");
                                matchPCT = matchPCT.Trim();
                                pctFound = true;
                            }
                            int minCount = Convert.ToInt32(matchPCT);
                            incFilterMins.Add(minCount);
                            incFilterPct.Add(pctFound);
                            if (pctFound && (minCount < 0 || minCount > 100))
                            {
                                Console.WriteLine("+f filter percentage must be between 0 and 100: " + minCount);
                                return;
                            }
                            if (args[p] == "+f" || args[p] == "+filter")
                                incFilterIsFuzzy.Add(false);
                            else
                                incFilterIsFuzzy.Add(true);
                        }
                        catch
                        {
                            Console.WriteLine("expected a number or percentage after the filter name: " + args[p + 2]);
                            return;
                        }
                        p += 2;
                        continue;
                    }

                    Console.WriteLine("unrecognised parameter: " + args[p]);
                    return;

                } // arg starts with +/-

                readsPatterns.Add(args[p]);
            }

            int kMerSize = 0;                        // set from filters

            // the final list of files to be filtered, derived by expanding all the names/patterns passed as parameters
            List<string> readsFNs = new List<string>();

            foreach (string readsPattern in readsPatterns)
            {
                string readsPatternPath = null;
                string readsPatternFNP = null;
                GetPathFN(readsPattern, out readsPatternPath, out readsPatternFNP);

                SearchOption so = SearchOption.TopDirectoryOnly;
                if (recursiveSearch)
                    so = SearchOption.AllDirectories;
                string[] readsFNsForPattern = Directory.GetFiles(readsPatternPath, readsPatternFNP, so);

                int noOfReadsFilesReturned = readsFNsForPattern.Length;
                if (noOfReadsFilesReturned == 0)
                {
                    Console.WriteLine("No matching sequences files found for " + readsPattern);
                    return;
                }

                foreach (string readsFN in readsFNsForPattern)
                    readsFNs.Add(readsFN);
            }

            if (outputDir != null)
                Directory.CreateDirectory(outputDir);

            if (pairedReads && readsFNs.Count % 2 != 0)
            {
                Console.WriteLine("-pairs option used but found " + readsFNs.Count + " files");
                return;
            }

            if (matchBothInPair && matchEitherInPair)
            {
                Console.WriteLine("can't ask to match both reads in pair AND either reads in pair");
                return;
            }

            if (incFilterNames.Count == 0 && excFilterNames.Count == 0)
            {
                Console.WriteLine("No filters specified");
                return;
            }

            DateTime start = DateTime.Now;

            List<MerHashSet> incFilters = new List<MerHashSet>(incFilterNames.Count);           // always canonical
            List<MerHashSet> incFiltersAsRead = new List<MerHashSet>(incFilterNames.Count);     // as read (for checking strand if not canonical)
            List<MerHashSet> incFiltersSeeds = new List<MerHashSet>(incFilterNames.Count);      // seeds from canonical kMers for fuzzy matching
            for (int f = 0; f < incFilterNames.Count; f++)
            {
                string fn = incFilterNames[f];
                int filterMerSize;
                bool canonical;
                MerHashSet incFilterAsRead;
                Console.WriteLine("loading filter " + fn);
                bool loadedOK = LoadTileFile(fn, out incFilterAsRead, out filterMerSize, out canonical);
                if (!loadedOK)
                {
                    Console.WriteLine("failed to load " + fn);
                    return;
                }

                if (kMerSize > 0 && filterMerSize != kMerSize)
                {
                    Console.WriteLine("kMer size mismatch for " + fn + " (expected " + kMerSize + " but found " + filterMerSize + ")");
                    return;
                }

                kMerSize = filterMerSize;

                // kMers are already in canonical form? 
                MerHashSet filterCanonical;
                if (canonical)
                {
                    incFilters.Add(incFilterAsRead);
                    incFiltersAsRead.Add(null);
                    filterCanonical = incFilterAsRead;
                }
                else
                // kMers were as-read, so keep these for checking and build the canonical set for scanning
                {
                    filterCanonical = new MerHashSet(incFilterAsRead.Capacity, kMerSize, false);
                    foreach (ulong kMer in incFilterAsRead)
                    {
                        ulong kMerRC = kMers.ReverseComplement(kMer, kMerSize);
                        filterCanonical.AddIfNotPresent(kMer < kMerRC ? kMer : kMerRC);
                    }
                    incFilters.Add(filterCanonical);
                    incFiltersAsRead.Add(incFilterAsRead);
                }

                MerHashSet incFilterSeeds = null;
                if (incFilterIsFuzzy[f])
                {
                    if (kMerSeedSize != 0)
                        incFilterSeeds = GenerateSeeds(filterCanonical, kMerSize, kMerSeedSize);
                    else
                        filterCanonical.AddSubVariants();
                }
                incFiltersSeeds.Add(incFilterSeeds);

                filterCanonical.Optimise();

                Console.WriteLine("loaded " + (!canonical ? incFilterAsRead.Count + "-->" : "") + filterCanonical.Count + " " + filterMerSize + "-mers from " + fn +
                    ". Matching at " + incFilterMins[f] + (incFilterPct[f] ? "%. " : ". ") + (incFilterSeeds != null ? incFilterSeeds.Count + " filter seeds." : ""));
            }

            List<MerHashSet> excFilters = new List<MerHashSet>(excFilterNames.Count);
            List<MerHashSet> excFiltersAsRead = new List<MerHashSet>(excFilterNames.Count);
            List<MerHashSet> excFiltersSeeds = new List<MerHashSet>(excFilterNames.Count);
            for (int f = 0; f < excFilterNames.Count; f++)
            {
                string fn = excFilterNames[f];
                Console.WriteLine("loading filter " + fn);
                int filterMerSize;
                bool canonical;
                MerHashSet excFilterAsRead;

                bool loadedOK = LoadTileFile(fn, out excFilterAsRead, out filterMerSize, out canonical);
                if (!loadedOK)
                {
                    Console.WriteLine("failed to load " + fn);
                    return;
                }

                if (kMerSize > 0 && filterMerSize != kMerSize)
                {
                    Console.WriteLine("kMer size mismatch for " + fn + " (expected " + kMerSize + ") - all filters have to be the same 'k'");
                    return;
                }

                kMerSize = filterMerSize;

                // kMers are already in canonical form? 
                MerHashSet filterCanonical;
                if (canonical)
                {
                    excFilters.Add(excFilterAsRead);
                    filterCanonical = excFilterAsRead;
                }
                else
                // kMers were as-read, so keep these for checking and build the canonical set for scanning
                {
                    filterCanonical = new MerHashSet(excFilterAsRead.Count, kMerSize, false);
                    foreach (ulong kMer in excFilterAsRead)
                    {
                        ulong kMerRC = kMers.ReverseComplement(kMer, kMerSize);
                        filterCanonical.AddNoCheck(kMer < kMerRC ? kMer : kMerRC);
                    }
                    excFilters.Add(filterCanonical);
                    excFiltersAsRead.Add(excFilterAsRead);
                }

                MerHashSet excFilterSeeds = null;
                if (excFilterIsFuzzy[f])
                {
                    if (kMerSeedSize != 0 && filterCanonical.Count > smallFilterSize)
                        excFilterSeeds = GenerateSeeds(filterCanonical, kMerSize, kMerSeedSize);
                    else
                        filterCanonical.AddSubVariants();
                }
                excFiltersSeeds.Add(excFilterSeeds);

                filterCanonical.Optimise();

                Console.WriteLine("loaded " + excFilterAsRead.Count + " " + filterMerSize + "-mers from " + fn + " matching at " + excFilterMins[f] + (excFilterPct[f] ? "%. " : ". ") + (excFilterSeeds != null ? excFilterSeeds.Count + " filter seeds." : ""));
            }

            if (lowComplexityFilter)
                Console.WriteLine("discarding low-complexity reads");

            Console.WriteLine("loaded " + (incFilters.Count + excFilters.Count) + " filters in " + (DateTime.Now - start).TotalSeconds.ToString("#.0") + "s.");

            if (minLen == 0)
                minLen = kMerSize;

            int noOfReadsFilesPerLoop = pairedReads ? 2 : 1;
            int noOfReadsFiles = readsFNs.Count;
            StreamReader[] reads = new StreamReader[noOfReadsFilesPerLoop];
            BufferedReader[] bufferedReads = new BufferedReader[noOfReadsFilesPerLoop];
            string[] readsDisplayFNs = new string[noOfReadsFilesPerLoop];
            StreamWriter[] filtered = new StreamWriter[noOfReadsFilesPerLoop];
            BufferedWriter[] filteredReads = new BufferedWriter[noOfReadsFilesPerLoop];
            string[] filteredReadsFNs = new string[noOfReadsFilesPerLoop];
            StreamWriter[] discarded = null;
            BufferedWriter[] discardedReads = null;
            string[] discardedReadsFNs = null;
            if (saveDiscards)
            {
                discarded = new StreamWriter[noOfReadsFilesPerLoop];
                discardedReads = new BufferedWriter[noOfReadsFilesPerLoop];
                discardedReadsFNs = new string[noOfReadsFilesPerLoop];
            }
            if (saveMatches)
                matches = new StreamWriter(runName + "_matches.txt");
            //rejects = new StreamWriter("lcfRejects.fna");

            int fileFormat = SeqFiles.DetermineFileFormat(readsFNs[0]);

            if (outputFormat == SeqFiles.formatNone)
                outputFormat = fileFormat;

            if (qualTrim && fileFormat != SeqFiles.formatFASTQ)
            {
                Console.WriteLine("can only quality-trim fastq files, option ignored");
                qualTrim = false;
            }

            if (qualTrim)
            {
                bool fullQualHeader;
                qualOffset = SeqFiles.ResolveFastqQualAmbiguity(readsFNs[0], out fullQualHeader);
            }

            int fileStep = pairedReads ? 2 : 1;

            long totalAcceptedReads = 0;
            long totalRejectedReads = 0;
            long totalSkippedReadsShort = 0;
            long totalWrittenReads = 0;
            long totalNoOfReads = 0;
            long keptReadsCount = 0;
            long discardedReadsCount = 0;
            long totalBasesQualTrimmed = 0;
            start = DateTime.Now;



            string discardsName = "discards";
            if (runName == discardsName)
                discardsName = "dropped";

            // start the monitor/synchronising thread
            Thread monitorProgress = new Thread(RateReporter);
            monitorProgress.Priority = ThreadPriority.AboveNormal;
            monitorProgress.Start();

            for (int f = 0; f < noOfReadsFiles; f += fileStep)
            {
                InitialiseFile(0, runName, discardsName, outputFormat, readsFNs[f], reads, bufferedReads, readsDisplayFNs,
                               filtered, filteredReads, filteredReadsFNs, discarded, discardedReads, discardedReadsFNs, fileFormat, threads);
                if (pairedReads)
                {
                    InitialiseFile(1, runName, discardsName, outputFormat, readsFNs[f + 1], reads, bufferedReads, readsDisplayFNs,
                                   filtered, filteredReads, filteredReadsFNs, discarded, discardedReads, discardedReadsFNs, fileFormat, threads);
                }
                keptReadsCount = 0;

                // prepare the reader threads and their parameters
                Thread[] filterThreads = new Thread[threads];
                readerThreadParams[] readerParams = new readerThreadParams[threads];

                for (int t = 0; t < threads; t++)
                {
                    readerParams[t] = new readerThreadParams();
                    readerParams[t].incFilters = incFilters;
                    readerParams[t].incFiltersAsRead = incFiltersAsRead;
                    readerParams[t].incFilterMins = incFilterMins;
                    readerParams[t].incFilterPct = incFilterPct;
                    readerParams[t].incFilterSeeds = incFiltersSeeds;
                    readerParams[t].excFilters = excFilters;
                    readerParams[t].excFilterMins = excFilterMins;
                    readerParams[t].excFilterPct = excFilterPct;
                    readerParams[t].excFilterSeeds = excFiltersSeeds;
                    readerParams[t].kMerSize = kMerSize;
                    readerParams[t].minLen = minLen;
                    readerParams[t].fileFormat = fileFormat;
                    readerParams[t].outputFormat = outputFormat;
                    readerParams[t].qualOffset = qualOffset;
                    readerParams[t].minQual = minQual;
                    readerParams[t].acceptedReads = 0;
                    readerParams[t].rejectedReads = 0;
                    readerParams[t].noOfReads = 0;
                    readerParams[t].writtenReads = 0;
                    readerParams[t].bufferedReads = bufferedReads;
                    readerParams[t].wantedAcceptedReads = acceptedReadsWanted/threads;
                    readerParams[t].filteredReads = filteredReads;
                    readerParams[t].discardedReads = discardedReads;
                    readerParams[t].readsDisplayFNs = readsDisplayFNs;
                    filterThreads[t] = new Thread(new ParameterizedThreadStart(Program.FilterReads));
                }

                if (pairedReads)
                    Console.WriteLine("filtering " + readsDisplayFNs[0] + " and " + readsDisplayFNs[1]);
                else
                    Console.WriteLine("filtering " + readsDisplayFNs[0]);

                // start the filtering reads for this file (pair)
                for (int t = 0; t < threads; t++)
                {
                    filterThreads[t].Start(readerParams[t]);
                }

                // and wait for all threads to finish
                for (int t = 0; t < filterThreads.Length; t++)
                {
                    filterThreads[t].Join();
                    totalAcceptedReads += readerParams[t].acceptedReads;
                    totalRejectedReads += readerParams[t].rejectedReads;
                    totalSkippedReadsShort += readerParams[t].skippedReadsShort;
                    totalNoOfReads += readerParams[t].noOfReads;
                    totalWrittenReads += readerParams[t].writtenReads;
                    keptReadsCount += readerParams[t].acceptedReads;
                    discardedReadsCount += readerParams[t].rejectedReads;
                    totalBasesQualTrimmed += readerParams[t].basesQualTrimmed;
                    // Console.WriteLine("finished matching thread " + t);
                }

                foreach (BufferedWriter fr in filteredReads)
                    fr.CloseBufferedWriter();

                if (discardedReads != null)
                    foreach (BufferedWriter dr in discardedReads)
                        dr.CloseBufferedWriter();

                foreach (StreamWriter sw in filtered)
                    sw.Close();
                if (discarded != null)
                    foreach (StreamWriter sw in discarded)
                        sw.Close();

                foreach (BufferedReader br in bufferedReads)
                    br.Close();

                // don't save empty files
                for (int i = 0; i < filteredReads.Length; i++)
                {
                    if (keptReadsCount == 0)
                        File.Delete(filteredReadsFNs[i]);
                    if (saveDiscards && discardedReadsCount == 0)
                        File.Delete(discardedReadsFNs[i]);
                }

            } // for all files (in pairs if necessary)

            BufferedWriter.FinishBufferWriter();

            stopReporter = true;
            signalReporter.Set();
            monitorProgress.Join();

            if (matches != null)
                matches.Close();
            //rejects.Close();

            Console.WriteLine("Kept " + totalWrittenReads + " from " + totalNoOfReads + " reads in " +
                                (DateTime.Now - start).TotalSeconds.ToString("#.0") + "s (" + 
                                totalAcceptedReads + " accepted, " + totalRejectedReads + " rejected, " +
                                totalSkippedReadsShort + " too short, " + totalBasesQualTrimmed + " bases qual-trimmed)");
            //if (kMersChecked > 0)
            //    Console.WriteLine("kmc=" + kMersChecked + " kmps=" + kMersPassedSeedCheck + " kmma=" + kMersMatchedAlready + " kmnma=" + kMersNotMatchedAlready + 
            //                     " kmvt=" + kMersVariantsTried + " kmvf=" + kMerVariantsFound + " CleanUnmatched=" + ranCleanUnmatched);
            // kmc=31,605,750,549 kmps=31,032,862,321 kmma=50,493,560 kmnma=21,964,643,810 kmvt=9,017,724,951 kmvf=4,349,952
            //Console.ReadLine();

        }

        private static void AddVariantsToFilter(MerHashSet filterCanonical, int kMerSize)
        {
            MerHashSet variants = new MerHashSet(filterCanonical.Count * kMerSize * 4, kMerSize, true);
            List<ulong> kMerVariants = new List<ulong>(kMerSize * 4);

            foreach (ulong kMer in filterCanonical)
            {
                kMerVariants.Clear();
                kMers.GenerateMerSubVariants(kMer, kMerVariants, kMerSize);
                foreach (ulong kmv in kMerVariants)
                {
                    ulong kmvRC = kMers.ReverseComplement(kmv, kMerSize);
                    variants.AddIfNotPresent(kmvRC < kmv ? kmvRC : kmv);
                }
            }

            foreach (ulong kmv in variants)
                filterCanonical.AddIfNotPresent(kmv);
        }

        private static MerHashSet GenerateSeeds(MerHashSet filterCanonical, int kMerSize, int kMerSeedSize)
        {
            // build exact matching 'seeds' for later variant matches. We'll only allow a single base mismatch so the top of the kMer
            // must be an exact match. We'll check these seeds before generating full variants. Generating full 1-base variants is too expensive for
            // larger reference sets, so these variants are generated on-the-fly and cached.
            MerHashSet filterSeeds = new MerHashSet(filterCanonical.Count / 2, kMerSeedSize);

            foreach (ulong kMer in filterCanonical)
            {
                // seeds from top of kMer
                ulong seed = kMer & seedMask;
                filterSeeds.AddIfNotPresent(seed);
                // retrieve other form (Y'X' from XY)
                ulong kMerRC = kMers.ReverseComplement(kMer, kMerSize);
                seed = kMerRC & seedMask;
                filterSeeds.AddIfNotPresent(seed);
            }

            // full variants generation for testing
            //kMerVariants.Clear();
            //int noOfVariants = kMers.GenerateMerSubVariants(kMer, kMerVariants, kMerSize);
            //foreach (ulong v in kMerVariants)
            //{
            //    ulong kMerRC = kMers.ReverseComplement(v, kMerSize);
            //    ulong kMerCanonical = v;
            //    if (kMerRC < v)
            //        kMerCanonical = kMerRC;
            //    filter.AddIfNotPresent(kMerCanonical);
            //}

            filterSeeds.Optimise();

            return filterSeeds;
        }

        private static void InitialiseFile(int idx, string runName, string discardsName, int outputFormat,
                                           string readsFN, StreamReader[] reads, BufferedReader[] bufferedReads, string[] readsDisplayFNs,
                                           StreamWriter[] filteredSW, BufferedWriter[] filteredReads, string[] filteredReadsFNs,
                                           StreamWriter[] discardedSW, BufferedWriter[] discardedReads, string[] discardedReadsFNs, int fileFormat, int threads)
        {
            reads[idx] = SeqFiles.OpenSeqStream(readsFN);
            bufferedReads[idx] = new BufferedReader(fileFormat, reads[idx], null);

            if (readsFN.EndsWith(".gz"))
                readsFN = readsFN.Substring(0, readsFN.Length - ".gz".Length);
            string fileSuffix = readsFN.Substring(readsFN.LastIndexOf('.'));
            string filePrefix = readsFN.Substring(0, readsFN.LastIndexOf('.'));
            string fileWithoutSuffix = readsFN.Substring(readsFN.LastIndexOf('\\') + 1);
            fileWithoutSuffix = fileWithoutSuffix.Substring(0, fileWithoutSuffix.LastIndexOf('.'));
            string finalFileSuffix = fileSuffix;
            // if we're converting the file format, it must be from fastq to fasta
            if (fileFormat != outputFormat)
                finalFileSuffix = ".fa";

            if (outputDir != null)
            {
                char fsSlash = Path.DirectorySeparatorChar;
                filePrefix = filePrefix.Substring(filePrefix.LastIndexOf(fsSlash) + 1);
                filePrefix = Path.Combine(outputDir, filePrefix);
            }
            string filteredFN = filePrefix + "_" + runName + finalFileSuffix;
            filteredSW[idx] = new StreamWriter(filteredFN);
            int bufferSize = (defaultHeaderLength + defaultReadLength) * batchSize;
            if (fileFormat == SeqFiles.formatFASTQ)
                bufferSize = 2 * bufferSize;
            filteredReads[idx] = new BufferedWriter(filteredSW[idx], bufferSize, threads, "kept");
            readsDisplayFNs[idx] = fileWithoutSuffix + fileSuffix;
            filteredReadsFNs[idx] = filteredFN;

            if (discardedReads != null)
            {
                string discardsFN = filePrefix + "_" + discardsName + finalFileSuffix;
                discardedSW[idx] = new StreamWriter(discardsFN);
                discardedReads[idx] = new BufferedWriter(discardedSW[idx], bufferSize, threads, "discards");
                discardedReadsFNs[idx] = discardsFN;
            }
        }

        private static void WriteUsage()
        {
            Console.WriteLine("usage: FilterReads -r tag [-t threads] [-pairs] [-full] [-matches] [-len minLen] [-first nnnn] [-s] [-qt minQual] [-o outputDir] [-fasta] [-discards] [+/-lcf] [+f|fz includeFilter minMatches[%|pct]] [-f|fz excludeFilter minMatches[%|pct]] readsFNs " + "(8-9-22)");
        }

        private static bool CheckForParamValue(int p, int argsLength, string msg)
        {
            if (p == argsLength)
            {
                Console.WriteLine(msg);
                return false;
            }
            return true;
        }

        private static void GetPathFN(string readsFN, out string readsPath, out string readsFNP)
        {
            char FSC = Path.DirectorySeparatorChar;
            string FSS = new string(FSC, 1);
            readsPath = null;
            if (readsFN.Contains(FSS))
            {
                readsPath = readsFN.Substring(0, readsFN.LastIndexOf(FSC));
                readsFNP = readsFN.Substring(readsFN.LastIndexOf(FSC) + 1);
            }
            else
            {
                readsPath = Directory.GetCurrentDirectory();
                readsFNP = readsFN;
            }
        }

        private static bool LoadTileFile(string tilesFN, out MerHashSet filter, out int kMerSize, out bool canonical)
        {
            BinaryReader tiledMersFile = null;
            string tiledMersFN = null;
            bool EOF = false;

            kMerSize = 0;
            canonical = false;
            filter = null;

            bool tileFileOpened = false;
            try
            {
                tiledMersFN = tilesFN;
                tiledMersFile = new BinaryReader(File.Open(tiledMersFN, FileMode.Open, FileAccess.Read, FileShare.Read));
                tileFileOpened = true;
            }
            catch
            {
                tileFileOpened = false;
            }

            if (!tileFileOpened)
            {
                Console.WriteLine("kMer filter file (" + tilesFN + ") not found");

                return false;
            }

            FileInfo fi = new FileInfo(tiledMersFN);
            long tileFileLength = fi.Length;
            int kMersInFile = (int)((tileFileLength - 4) / 8 + 1);

            // read and parse the header int
            uint headerInt = tiledMersFile.ReadUInt32();
            int version = (int)(headerInt >> 24) + 1;
            if (version != 1 && version != 2)
            {
                Console.WriteLine(".mer file needs to be V1 or V2, found V" + version);
                return false;
            }
            kMerSize = (int)(headerInt & 0x000000ff);
            if (kMerSize > 32)
            {
                Console.WriteLine("kMers can only be <=32b, found " + kMerSize);
                return false;
            }
            if (version == 1)
                canonical = true;
            if (version == 2)
                canonical = (int)((headerInt & 0x00ff0000) >> 16) == 1;

            if (kMerSeedSize == 0 || kMersInFile <= smallFilterSize)
                kMersInFile = kMersInFile * kMerSize * 4;
            filter = new MerHashSet(kMersInFile, kMerSize, canonical);

            while (!EOF)
            {
                try                                             // read the next kMer from the binary stream - will generate exception at EOF
                {
                    ulong kMer = tiledMersFile.ReadUInt64();    // only distinct as-read/canonical kMers are expected in this file
                    filter.AddNoCheck(kMer);                    // no need to check as kMers will be distinct 
                }
                catch
                {
                    EOF = true;
                    break;
                }
            }

            tiledMersFile.Close();
            //filter.Optimise();                                  // table is now read-only so unused space can be returned

            return true;
        }

        private static void FilterReads(object threadParams)
        {
            readerThreadParams theseParams = (readerThreadParams)threadParams;

            List<MerHashSet> incFilters = theseParams.incFilters;
            List<MerHashSet> incFiltersAsRead = theseParams.incFiltersAsRead;
            List<int> incFilterMins = theseParams.incFilterMins;
            List<bool> incFilterPct = theseParams.incFilterPct;
            List<MerHashSet> incFilterSeeds = theseParams.incFilterSeeds;
            List<MerHashSet> excFilters = theseParams.excFilters;
            List<int> excFilterMins = theseParams.excFilterMins;
            List<bool> excFilterPct = theseParams.excFilterPct;
            List<MerHashSet> excFilterSeeds = theseParams.excFilterSeeds;
            int kMerSize = theseParams.kMerSize;
            int minLen = theseParams.minLen;
            BufferedReader[] bufferedReads = theseParams.bufferedReads;
            int wantedAcceptedReads = theseParams.wantedAcceptedReads;
            if (wantedAcceptedReads == 0)
                wantedAcceptedReads = int.MaxValue;
            int outputFormat = theseParams.outputFormat;
            string[] readsDisplayFNs = theseParams.readsDisplayFNs;
            BufferedWriter[] filteredReads = theseParams.filteredReads;
            BufferedWriter[] discardedReads = theseParams.discardedReads;
            int minQual = theseParams.minQual;
            int qualOffset = theseParams.qualOffset;

            long thread_kMersChecked = 0;
            long thread_kMersPassedSeedCheck = 0;
            long thread_kMersVariantsTried = 0;
            long thread_kMerVariantsFound = 0;
            long thread_kMersNotMatchedAlready = 0;
            long thread_kMersMatchedAlready = 0;

            int noOfReadsFiles = bufferedReads.Length;

            long acceptedReads = 0;
            long rejectedReads = 0;
            long skippedReadsShort = 0;
            long writtenReads = 0;
            long noOfReads = 0;
            long basesQualTrimmed = 0;

            int filesStillActive = noOfReadsFiles;                               // how many active reads files are still around
            Sequence[][] headerSet = new Sequence[noOfReadsFiles][];             // a set of read headers
            Sequence[][] readSet = new Sequence[noOfReadsFiles][];               // a set of reads, possibly one from each file (length+char[])
            Sequence[][] qualHeaderSet = new Sequence[noOfReadsFiles][];         // set of headers for the quals
            Sequence[][] qualsSet = new Sequence[noOfReadsFiles][];              // set of quals 
            bool[][] acceptedRead = new bool[noOfReadsFiles][];                  // results of filtering a batch of reads (status per read) [f][r]
            bool[][] rejectedRead = new bool[noOfReadsFiles][];
            int[][] NsInRead = new int[noOfReadsFiles][];                        // how many N's were found in the read
            List<int>[][] savedMatchedAcceptLocs = new List<int>[noOfReadsFiles][];          // saved matching kMer locations (acccept) [file#]{readNo#]
            List<ulong>[][] savedMatchedAcceptNVMers = new List<ulong>[noOfReadsFiles][];    // saved matching non-variant kMers (acccept)
            List<int>[][] savedMatchedRejectLocs = new List<int>[noOfReadsFiles][];          // saved matching kMer locations (reject)
            List<int>[][] savedMatchedLCLocs = new List<int>[noOfReadsFiles][];              // saved low complexity locations 

            BufferedWriter.WriteBuffer[] filteredReadsWriteBuffers = new BufferedWriter.WriteBuffer[noOfReadsFiles];
            BufferedWriter.WriteBuffer[] discardedReadsWriteBuffers = null;
            if (discardedReads != null)
                discardedReadsWriteBuffers = new BufferedWriter.WriteBuffer[noOfReadsFiles];

            for (int p = 0; p < noOfReadsFiles; p++)
            {
                headerSet[p] = new Sequence[batchSize];
                readSet[p] = new Sequence[batchSize];
                qualHeaderSet[p] = new Sequence[batchSize];
                qualsSet[p] = new Sequence[batchSize];
                acceptedRead[p] = new bool[batchSize];
                rejectedRead[p] = new bool[batchSize];
                NsInRead[p] = new int[batchSize];
                for (int r = 0; r < batchSize; r++)
                {
                    headerSet[p][r] = new Sequence(defaultHeaderLength);
                    readSet[p][r] = new Sequence(defaultReadLength);
                    qualHeaderSet[p][r] = new Sequence(defaultHeaderLength);
                    qualsSet[p][r] = new Sequence(defaultReadLength);
                }
                if (saveMatches)
                {
                    savedMatchedAcceptLocs[p] = new List<int>[batchSize];
                    savedMatchedAcceptNVMers[p] = new List<ulong>[batchSize];
                    savedMatchedRejectLocs[p] = new List<int>[batchSize];
                    savedMatchedLCLocs[p] = new List<int>[batchSize];
                    for (int r = 0; r < batchSize; r++)
                    {
                        savedMatchedAcceptLocs[p][r] = new List<int>();
                        savedMatchedAcceptNVMers[p][r] = new List<ulong>();
                        savedMatchedRejectLocs[p][r] = new List<int>();
                        savedMatchedLCLocs[p][r] = new List<int>();
                    }
                }
                filteredReadsWriteBuffers[p] = null;
                if (discardedReadsWriteBuffers != null)
                    discardedReadsWriteBuffers[p] = null;
            }

            // per-read and per-set data allocated outside of reading loop for performance reasons
            ulong[] merSet = new ulong[1000];
            bool[] merValid = new bool[1000];
            int[] incMatchesForRead = new int[incFilters.Count];
            int[] excMatchesForRead = new int[excFilters.Count];
            int[] matchedAsRead = new int[incFilters.Count];
            int[] matchedAsReadRC = new int[incFilters.Count];
            bool[] fullLengthAccMatched = new bool[incFilters.Count];
            bool[] fullLengthRejMatched = new bool[excFilters.Count];
            SortedSet<int>[] matchedAcceptedMerLocs = new SortedSet<int>[incFilters.Count];
            Dictionary<int, int>[] matchedAcceptedCoveredBases = new Dictionary<int, int>[incFilters.Count];
            List<ulong>[] matchedAcceptedNVMers = new List<ulong>[incFilters.Count];
            SortedSet<int>[] matchedRejectedMerLocs = new SortedSet<int>[excFilters.Count];
            Dictionary<int, int>[] matchedRejectedCoveredBases = new Dictionary<int, int>[excFilters.Count];
            List<int> matchedLCMerLocs = new List<int>();
            MerDictionary<ulong>[] incFilterVariantMatched = new MerDictionary<ulong>[incFilters.Count];
            MerDictionary<ulong>[] excFilterVariantMatched = new MerDictionary<ulong>[excFilters.Count];
            Dictionary<ulong, long>[] incCommonUnmatched = new Dictionary<ulong, long>[incFilters.Count];
            Dictionary<ulong, long>[] excCommonUnmatched = new Dictionary<ulong, long>[excFilters.Count];
            int[] incCommonUnmatchedCleanPoint = new int[incFilters.Count];
            int[] excCommonUnmatchedCleanPoint = new int[excFilters.Count];
            List<ulong> kMersToRemoveOnCleaning = new List<ulong>(unmatchedLength);
            for (int i = 0; i < incFilters.Count; i++)
            {
                matchedAcceptedMerLocs[i] = new SortedSet<int>();
                matchedAcceptedCoveredBases[i] = new Dictionary<int, int>(500);
                matchedAcceptedNVMers[i] = new List<ulong>();
                incFilterVariantMatched[i] = new MerDictionary<ulong>(10000, kMerSize);
                incCommonUnmatched[i] = new Dictionary<ulong, long>(unmatchedLength);
                incCommonUnmatchedCleanPoint[i] = unmatchedLength;
            }
            for (int i = 0; i < excFilters.Count; i++)
            {
                matchedRejectedMerLocs[i] = new SortedSet<int>();
                matchedRejectedCoveredBases[i] = new Dictionary<int, int>(500);
                excFilterVariantMatched[i] = new MerDictionary<ulong>(10000, kMerSize);
                excCommonUnmatched[i] = new Dictionary<ulong, long>(unmatchedLength);
                excCommonUnmatchedCleanPoint[i] = unmatchedLength;
            }
            int[] incFilterMinsRead = new int[incFilterMins.Count];
            int[] excFilterMinsRead = new int[excFilterMins.Count];
            int lastReadLength = 0;

            // low complexity reads - allocated here to save on allocs
            Dictionary<ulong, int> distinctTriplets = new Dictionary<ulong, int>(1000);
            int[] sortedReps = new int[64];

            // save allocation in depths of variant scan
            List<ulong> kMerVariants = new List<ulong>(1000);

            //string targetHeader = "@GWNJ-0901:744:GW210105000:7:1110:10196:38034 2:N:0:AGAGTCCA+GACACAGT";

            while (filesStillActive > 0)
            {
                if (acceptedReads >= wantedAcceptedReads)
                    break;

                // read the next read from each of the files together - giving a pair of reads if we have paired reads - and do this for a batch to reduce locking overhead
                int readsRead = 0;                          // no of reads in this batch
                lock (bufferedReads)
                {
                    for (int p = 0; p < noOfReadsFiles; p++)
                    {
                        readsRead = bufferedReads[p].ReadReads(batchSize, headerSet[p], readSet[p], qualHeaderSet[p], qualsSet[p]);

                        if (readsRead != batchSize)
                            filesStillActive--;

                        progressReadsRead += readsRead;
                    }
                } // lock to ensure synchronised reading from all reads files (and pairing)

                thread_kMersChecked = 0;
                thread_kMersPassedSeedCheck = 0;
                thread_kMersVariantsTried = 0;
                thread_kMerVariantsFound = 0;
                thread_kMersNotMatchedAlready = 0;
                thread_kMersMatchedAlready = 0;

                // filter the just-acquired batch of reads
                for (int r = 0; r < readsRead; r++)
                {
                    // process each read/pair of reads 
                    for (int p = 0; p < readSet.Length; p++)
                    {
                        noOfReads++;
                        Sequence currentRead = readSet[p][r];
                        int NsFound = 0;

                        if (qualTrim)
                            basesQualTrimmed += SeqFiles.TrimTrailingPoorQuals(readSet[p][r], qualsSet[p][r], minQual, qualOffset);

                        if (currentRead.Length < minLen)
                        {
                            skippedReadsShort++;
                            acceptedRead[p][r] = false;
                            rejectedRead[p][r] = true;
                            progressReadsRejected++;
                            continue;
                        }

                        foreach (SortedSet<int> matchedLocs in matchedAcceptedMerLocs)
                            matchedLocs.Clear();
                        foreach (List<ulong> matchedAcceptedNVMer in matchedAcceptedNVMers)
                            matchedAcceptedNVMer.Clear();
                        foreach (SortedSet<int> matchedLocs in matchedRejectedMerLocs)
                            matchedLocs.Clear();
                        if (lowComplexityFilter)
                            matchedLCMerLocs.Clear();

                        // defaults
                        acceptedRead[p][r] = incFilters.Count == 0;
                        rejectedRead[p][r] = false;
                        NsInRead[p][r] = 0;

                        int currentReadLength = currentRead.Length;

                        // calculate min cutoffs (in bases) for each filter if the read/contig length has changed
                        if (currentReadLength != lastReadLength)
                        {
                            for (int f = 0; f < incFilters.Count; f++)
                            {
                                if (incFilterPct[f])
                                    incFilterMinsRead[f] = currentReadLength * incFilterMins[f] / 100;
                                else
                                    incFilterMinsRead[f] = incFilterMins[f];
                            }
                            for (int f = 0; f < excFilters.Count; f++)
                            {
                                if (excFilterPct[f])
                                    excFilterMinsRead[f] = currentReadLength * excFilterMins[f] / 100;
                                else
                                    excFilterMinsRead[f] = excFilterMins[f];
                            }
                            lastReadLength = currentReadLength;
                        }

                        //if (headerSet[p][r].ToString().StartsWith(targetHeader))
                        //{
                        //    //tracing = true;
                        //    Debugger.Break();
                        //}
                        //if (currentRead.ToString() == "GATATGAAATAAAACTGGAACAGGAATAAACTCATATCAACGATAAATGAAAAGTTTTTTAGGCAAGGATGACTTTTATGTATGATTTTTCTTGCGCACA")
                        //    Debugger.Break();

                        CountMatchesForRead(currentRead, incFilters, excFilters, incFilterSeeds, excFilterSeeds, incFilterVariantMatched, excFilterVariantMatched, incCommonUnmatched, excCommonUnmatched,
                                            kMerSize, ref merSet, ref merValid, out NsFound, incMatchesForRead, excMatchesForRead, matchedAcceptedMerLocs, matchedAcceptedCoveredBases, matchedAcceptedNVMers, matchedRejectedMerLocs, matchedRejectedCoveredBases, kMerVariants,
                                            ref thread_kMersChecked, ref thread_kMersPassedSeedCheck, ref thread_kMersVariantsTried, ref thread_kMerVariantsFound, ref thread_kMersNotMatchedAlready, ref thread_kMersMatchedAlready);

                        for (int f = 0; f < incFilters.Count; f++)
                        {
                            bool passedThisFilter = incMatchesForRead[f] >= incFilterMinsRead[f];
                            fullLengthAccMatched[f] = false;
                            if (passedThisFilter && fullLength)
                            {
                                fullLengthAccMatched[f] = FullLengthMatches(matchedAcceptedCoveredBases[f], currentReadLength, incFilterMinsRead[f] / 3);
                                passedThisFilter = fullLengthAccMatched[f];
                            }
                            acceptedRead[p][r] = acceptedRead[p][r] | passedThisFilter;
                            
                            // maintenance of commonly-found variant cache
                            if (incCommonUnmatched[f].Count > incCommonUnmatchedCleanPoint[f])
                            {
                                CleanUnmatched(incCommonUnmatched[f], kMersToRemoveOnCleaning);
                                incCommonUnmatchedCleanPoint[f] = Math.Max(incCommonUnmatchedCleanPoint[f], incCommonUnmatched[f].Count * 3 / 2);
                            }
                        }

                        for (int f = 0; f < excFilters.Count; f++)
                        {
                            // fail if total number of reject bases is higher than limit
                            bool failedThisFilter = excMatchesForRead[f] >= excFilterMinsRead[f];
                            fullLengthRejMatched[f] = false;
                            // also fail if piece-wise test exceeds limit
                            if (fullLength)
                                fullLengthRejMatched[f] = FullLengthMatches(matchedRejectedCoveredBases[f], currentReadLength, excFilterMinsRead[f] / 3);
                            failedThisFilter |= fullLengthRejMatched[f];
                            rejectedRead[p][r] = rejectedRead[p][r] | failedThisFilter;
                            if (excCommonUnmatched[f].Count > excCommonUnmatchedCleanPoint[f])
                            {
                                CleanUnmatched(excCommonUnmatched[f], kMersToRemoveOnCleaning);
                                excCommonUnmatchedCleanPoint[f] = Math.Max(excCommonUnmatchedCleanPoint[f], excCommonUnmatched[f].Count * 3 / 2);
                            }
                        }

                        //Console.WriteLine(r + "\t+" + incMatchesForRead[0] + "[+" + matchedAsRead[0] + ",-" + matchedAsReadRC[0] + "]/" + incFilterMinsRead[0] + " " + matchedAcceptedCoveredBases[0].Count + "b" + " acc=" + acceptedRead[p][r] + " full=" + fullLengthAccMatched[0] +
                        //                      "\t-" + excMatchesForRead[0] + "/" + excFilterMinsRead[0] + " " + matchedRejectedCoveredBases[0].Count + "b" +" rej=" + rejectedRead[p][r] + " full=" + fullLengthRejMatched[0] + " " + headerSet[p][r].ToString());

                        NsInRead[p][r] = NsFound;

                        // looks like we might be about to accept this read - so check it for low complexity now if we've been asked to do so (deferred to avoid overhead)
                        if (lowComplexityFilter && acceptedRead[p][r] && !rejectedRead[p][r])
                            rejectedRead[p][r] = CheckForLowComplexity(currentRead, ref merSet, ref merValid, matchedLCMerLocs, distinctTriplets, sortedReps);

                        if (rejectedRead[p][r])
                        {
                            acceptedRead[p][r] = false;        // rejected trumps accepted
                            progressReadsRejected++;
                        }

                        if (saveMatches)
                        {
                            savedMatchedAcceptLocs[p][r].Clear();
                            savedMatchedAcceptNVMers[p][r].Clear();
                            savedMatchedRejectLocs[p][r].Clear();
                            savedMatchedLCLocs[p][r].Clear();

                            for (int f = 0; f < incFilters.Count; f++)
                            {
                                foreach (int loc in matchedAcceptedMerLocs[f])
                                    savedMatchedAcceptLocs[p][r].Add(loc);
                                foreach (ulong kMer in matchedAcceptedNVMers[f])
                                    savedMatchedAcceptNVMers[p][r].Add(kMer);
                            }
                            for (int f = 0; f < excFilters.Count; f++)
                                foreach (int loc in matchedRejectedMerLocs[f])
                                    savedMatchedRejectLocs[p][r].Add(loc);
                            foreach (int loc in matchedLCMerLocs)
                                savedMatchedLCLocs[p][r].Add(loc);
                        }

                        //if (saveMatches)
                        //{
                        //    matches.WriteLine(headerSet[r][b].ToString() + " A=" + acceptedRead[p][r] + " R=" + rejectedRead[p][r]);
                        //    WriteMatchDetails(matches, "inc", incFilterMinsRead, incMatchesForRead, matchedAcceptedMerLocs);
                        //    WriteMatchDetails(matches, "exc", excFilterMinsRead, excMatchesForRead, matchedRejectedMerLocs);
                        //}

                    } // for each read in the file set
                } // for each read in the batch

                kMersChecked += thread_kMersChecked;
                kMersPassedSeedCheck += thread_kMersPassedSeedCheck;
                kMersVariantsTried += thread_kMersVariantsTried;
                kMerVariantsFound += thread_kMerVariantsFound;
                kMersNotMatchedAlready += thread_kMersNotMatchedAlready;
                kMersMatchedAlready += thread_kMersMatchedAlready;

                // if reading fastq but writing fasta, change the header character before writing the filtered read
                for (int p = 0; p < noOfReadsFiles; p++)
                    for (int r = 0; r < readsRead; r++)
                        if (outputFormat == SeqFiles.formatFNA && headerSet[p][r].Bases[0] == '@')
                            headerSet[p][r].Bases[0] = '>';

                // and now write the filtered reads for the batch
                // get some buffers first (unless we've already got unused ones around)
                int filteredWrittenInBatch = 0;
                int discardedWrittenInBatch = 0;
                for (int p = 0; p < noOfReadsFiles; p++)
                    if (filteredReadsWriteBuffers[p] == null)
                        filteredReadsWriteBuffers[p] = filteredReads[p].GetWriteBuffer();
                if (discardedReads != null)
                    for (int p = 0; p < noOfReadsFiles; p++)
                        if (discardedReadsWriteBuffers[p] == null)
                            discardedReadsWriteBuffers[p] = discardedReads[p].GetWriteBuffer();

                for (int r = 0; r < readsRead; r++)
                {
                    if (matchBothInPair)
                    {
                        if (acceptedRead[0][r] && acceptedRead[1][r] && readSet[0][r].Length >= minLen && readSet[1][r].Length >= minLen)
                        {
                            writtenReads += 2;
                            progressReadsAccepted += 2;
                            acceptedReads += 2;

                            filteredWrittenInBatch += 2;
                            // writes are to local (per-thread) buffers so no locks are needed. Buffers are written as locked-protected pairs. 
                            WriteSeq(filteredReads[0], filteredReadsWriteBuffers[0], headerSet[0][r], readSet[0][r], qualHeaderSet[0][r], qualsSet[0][r], outputFormat);
                            WriteSeq(filteredReads[1], filteredReadsWriteBuffers[1], headerSet[1][r], readSet[1][r], qualHeaderSet[1][r], qualsSet[1][r], outputFormat);

                            if (saveMatches)
                            {
                                WriteMatchingSeq("kept", kMerSize, savedMatchedAcceptLocs[0][r], savedMatchedAcceptNVMers[0][r], savedMatchedRejectLocs[0][r], savedMatchedLCLocs[0][r], readsDisplayFNs[0], headerSet[0][r], readSet[0][r]);
                                WriteMatchingSeq("kept", kMerSize, savedMatchedAcceptLocs[1][r], savedMatchedAcceptNVMers[1][r], savedMatchedRejectLocs[1][r], savedMatchedLCLocs[1][r], readsDisplayFNs[1], headerSet[1][r], readSet[1][r]);
                            }
                        }
                        else
                        {
                            rejectedReads += 2;

                            if (discardedReads != null)
                            {
                                discardedWrittenInBatch += 2;
                                WriteSeq(discardedReads[0], discardedReadsWriteBuffers[0], headerSet[0][r], readSet[0][r], qualHeaderSet[0][r], qualsSet[0][r], outputFormat);
                                WriteSeq(discardedReads[1], discardedReadsWriteBuffers[1], headerSet[1][r], readSet[1][r], qualHeaderSet[1][r], qualsSet[1][r], outputFormat);
                            }
                        }
                        continue;
                    }

                    if (matchEitherInPair && (acceptedRead[0][r] || acceptedRead[1][r]))
                    {
                        // 'accepted' reads are always accepted. Paired read must be OK (not explicitly rejected, long enough & no Ns)
                        bool writeR0 = !rejectedRead[0][r] && readSet[0][r].Length >= minLen && (NsInRead[0][r] == 0 || acceptedRead[0][r]);
                        bool writeR1 = !rejectedRead[1][r] && readSet[1][r].Length >= minLen && (NsInRead[1][r] == 0 || acceptedRead[1][r]);

                        if (writeR0 && writeR1)
                        {
                            writtenReads += 2;
                            if (acceptedRead[0][r])
                            {
                                acceptedReads++;
                                progressReadsAccepted++;
                            }
                            if (acceptedRead[1][r])
                            {
                                acceptedReads++;
                                progressReadsAccepted++;
                            }

                            filteredWrittenInBatch += 2;
                            WriteSeq(filteredReads[0], filteredReadsWriteBuffers[0], headerSet[0][r], readSet[0][r], qualHeaderSet[0][r], qualsSet[0][r], outputFormat);
                            WriteSeq(filteredReads[1], filteredReadsWriteBuffers[1], headerSet[1][r], readSet[1][r], qualHeaderSet[1][r], qualsSet[1][r], outputFormat);

                            if (saveMatches)
                            {
                                WriteMatchingSeq("kept", kMerSize, savedMatchedAcceptLocs[0][r], savedMatchedAcceptNVMers[0][r], savedMatchedRejectLocs[0][r], savedMatchedLCLocs[0][r], readsDisplayFNs[0], headerSet[0][r], readSet[0][r]);
                                WriteMatchingSeq("kept", kMerSize, savedMatchedAcceptLocs[1][r], savedMatchedAcceptNVMers[1][r], savedMatchedRejectLocs[1][r], savedMatchedLCLocs[1][r], readsDisplayFNs[1], headerSet[1][r], readSet[1][r]);
                            }
                        }
                        else
                        {
                            rejectedReads += 2;

                            if (discardedReads != null)
                            {
                                discardedWrittenInBatch += 2;
                                WriteSeq(discardedReads[0], discardedReadsWriteBuffers[0], headerSet[0][r], readSet[0][r], qualHeaderSet[0][r], qualsSet[0][r], outputFormat);
                                WriteSeq(discardedReads[1], discardedReadsWriteBuffers[1], headerSet[1][r], readSet[1][r], qualHeaderSet[1][r], qualsSet[1][r], outputFormat);
                            }
                        }
                        continue;
                    }

                    // not paired reads
                    {
                        if (acceptedRead[0][r])
                        {
                            progressReadsAccepted++;
                            acceptedReads++;
                            writtenReads++;

                            filteredWrittenInBatch++;
                            WriteSeq(filteredReads[0], filteredReadsWriteBuffers[0], headerSet[0][r], readSet[0][r], qualHeaderSet[0][r], qualsSet[0][r], outputFormat);

                            if (saveMatches)
                                WriteMatchingSeq("kept", kMerSize, savedMatchedAcceptLocs[0][r], savedMatchedAcceptNVMers[0][r], savedMatchedRejectLocs[0][r], savedMatchedLCLocs[0][r], readsDisplayFNs[0], headerSet[0][r], readSet[0][r]);
                        }
                        else
                        {
                            rejectedReads++;

                            if (discardedReads != null)
                            {
                                discardedWrittenInBatch++;
                                WriteSeq(discardedReads[0], discardedReadsWriteBuffers[0], headerSet[0][r], readSet[0][r], qualHeaderSet[0][r], qualsSet[0][r], outputFormat);
                            }
                        }
                    }

                } // writing a batch of reads

                if (filteredWrittenInBatch > 0)
                {
                    BufferedWriter.WritePairedBufferSet(filteredReadsWriteBuffers);
                    for (int p = 0; p < noOfReadsFiles; p++)
                        filteredReadsWriteBuffers[p] = null;
                }

                if (discardedWrittenInBatch > 0)
                {
                    BufferedWriter.WritePairedBufferSet(discardedReadsWriteBuffers);
                    for (int p = 0; p < noOfReadsFiles; p++)
                        discardedReadsWriteBuffers[p] = null;
                }

            } // until all files are at EOF

            // return any unused write buffers
            for (int p = 0; p < noOfReadsFiles; p++)
                if (filteredReadsWriteBuffers[p] != null)
                    filteredReads[p].ReturnWriteBuffer(filteredReadsWriteBuffers[p]);
            if (discardedReads != null)
                for (int p = 0; p < noOfReadsFiles; p++)
                    if (discardedReadsWriteBuffers[p] != null)
                        discardedReads[p].ReturnWriteBuffer(discardedReadsWriteBuffers[p]);

            theseParams.acceptedReads = acceptedReads;
            theseParams.rejectedReads = rejectedReads;
            theseParams.skippedReadsShort = skippedReadsShort;
            theseParams.writtenReads = writtenReads;
            theseParams.basesQualTrimmed = basesQualTrimmed;
            theseParams.noOfReads = noOfReads;
        }

        private static void WriteSeq(BufferedWriter bufferedReadsWriter, BufferedWriter.WriteBuffer readsBuffer, Sequence readHeader, Sequence read, Sequence qualHeader, Sequence quals, int fileFormat)
        {
            WriteSeqLine(bufferedReadsWriter, readsBuffer, readHeader, read, fileFormat);
            if (fileFormat == SeqFiles.formatFASTQ)
                WriteSeqLine(bufferedReadsWriter, readsBuffer, qualHeader, quals, fileFormat);
        }

        private static void WriteSeqLine(BufferedWriter bufferedWriter, BufferedWriter.WriteBuffer buffer, Sequence readHeader, Sequence readSeq, int fileFormat)
        {
            // @1:1:0:686#0/1
            // NTGGAGAATTCTGGATCCTCGGACTAAAACAATAGCAGTTGATTCGCTCACAGTTCTGGAGGCTAGAGGTATGAAA
            // +1:1:0:686#0/1
            // @hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh\hhhhhhhhhhhhhhhhVg[hhhU^hhWhfgVhc^Dhh`_V
            //
            // >FUOCO2J02IPX2K rank=0000260 x=3458.0 y=3626.0 length=70
            // GAGCAGCTCCTCAAGCAACTGCAACTGGATTGAGCAAGGAATGTTCGCAGCTACCCGACT
            // GACCCGTCTT

            // write out the header if it exists
            if (readHeader != null)
                bufferedWriter.WriteLine(buffer, readHeader);

            if (fileFormat == SeqFiles.formatFNA)
            {
                // if we concatenated shorter fasta lines when the data was read,
                // we'll now split it again as it's being written
                int m = 0;
                int hrLen = readSeq.Length;
                while (m < hrLen)
                {
                    int wLen = Math.Min(80, hrLen - m);
                    bufferedWriter.WriteLine(buffer, readSeq, m, wLen);
                    m += 80;
                }
            }
            else
            {
                bufferedWriter.WriteLine(buffer, readSeq);
            }
        }

        private static void CleanUnmatched(Dictionary<ulong, long> kMersNotMatched, List<ulong> kMersToRemove)
        {
            ranCleanUnmatched++;

            double invSum = 0.0;
            long maxReps = 0;
            foreach (long rep in kMersNotMatched.Values)
            {
                invSum += 1.0f / (double)rep;
                if (rep > maxReps)
                    maxReps = rep;
            }

            int meanReps = (int)((double)kMersNotMatched.Count / invSum);
            if (maxReps < 10 * meanReps)
                return;

            kMersToRemove.Clear();
            foreach (KeyValuePair<ulong, long> kvp in kMersNotMatched)
                if (kvp.Value == 1)
                    kMersToRemove.Add(kvp.Key);

            foreach (ulong kMer in kMersToRemove)
                kMersNotMatched.Remove(kMer);
        }

        private static bool FullLengthMatches(Dictionary<int, int> coveredBases, int readLength, int minInPart)
        {
            int matchesInFirstThird = 0;
            for (int i = 0; i < readLength / 3; i++)
                if (coveredBases.ContainsKey(i) && coveredBases[i] > 1)
                    matchesInFirstThird++;
            int matchesInSecondThird = 0;
            for (int i = readLength / 3; i < readLength * 2 / 3; i++)
                if (coveredBases.ContainsKey(i) && coveredBases[i] > 1)
                    matchesInSecondThird++;
            int matchesInLastThird = 0;
            for (int i = readLength * 2 / 3; i < readLength; i++)
                if (coveredBases.ContainsKey(i) && coveredBases[i] > 1)
                    matchesInLastThird++;

            int matchingSegments = 0;
            if (matchesInFirstThird >= (2 * minInPart / 3))
                matchingSegments++;
            if (matchesInSecondThird >= minInPart)
                matchingSegments++; 
            if (matchesInLastThird >= (2 * minInPart / 3))
                matchingSegments++;
            // base coverage comes from kMer coverage, so failing start/end kMer matches can lead to disproportionate base mismatches (without correction for mismatches)
            // and need matches for 2/3 segments. 
            return matchingSegments >= 2;
        }

        private static bool CheckForLowComplexity(Sequence read, ref ulong[] merSet, ref bool[] merValid, List<int> LCLocs, Dictionary<ulong, int> distinctSet, int[] reps)
        {
            bool lcRead = false;

            distinctSet.Clear();

            int tripletsCount = Sequence.GenerateMersFromRead(read, lcSize, ref merSet, ref merValid);

            for (int i = 0; i < tripletsCount; i++)
            {
                if (merValid[i])
                {
                    ulong triplet = merSet[i];
                    if (distinctSet.ContainsKey(triplet))
                        distinctSet[triplet]++;
                    else
                        distinctSet.Add(triplet, 1);
                }
            }

            // see how many distinct triplets we need to cover 90% of the read
            distinctSet.Values.CopyTo(reps, 0);
            Array.Sort<int>(reps, 0, distinctSet.Count);
            int threshhold = tripletsCount * 90 / 100;
            int cumulativeReps = 0;
            int repsIncluded = 0;
            int lastReps = 0;
            for (int i = distinctSet.Count - 1; i >= 0; i--)
            {
                cumulativeReps += reps[i];
                repsIncluded++;
                if (cumulativeReps > threshhold)
                {
                    lastReps = reps[i];
                    break;
                }
            }

            // if read can be covered by ~10% of the possible 3-mers, say it's low complexity
            if (repsIncluded <= 7)
            {
                LCLocs.Clear();
                for (int i = 0; i < tripletsCount; i++)
                    if (!merValid[i] || distinctSet[merSet[i]] >= lastReps)
                        LCLocs.Add(i);
                lcRead = true;
            }

            return lcRead;
        }

        private static void WriteMatchingSeq(string fate, int kMerSize, List<int> matchedAcceptedMerLocs, List<ulong> matchedAcceptedNVMers, List<int> matchedRejectedMerLocs, List<int> lcMerLocs, string FN, Sequence header, Sequence read)
        {
            string blanks = new string(' ', read.Length);
            StringBuilder markersAccSB = new StringBuilder(blanks);
            StringBuilder kMerAccSB = new StringBuilder(blanks);
            StringBuilder markersRejSB = new StringBuilder(blanks);
            StringBuilder markersLCFSB = new StringBuilder(blanks);

            int acceptedMatches = 0;
            int rejectedMatches = 0;
            int lcMatches = 0;

            //string matchedMers = "";
            for (int i = 0; i < matchedAcceptedMerLocs.Count; i++)
            {
                int loc = matchedAcceptedMerLocs[i];
                for (int b = 0; b < kMerSize; b++)
                    markersAccSB[loc + b] = '^';
                string kMerNV = kMers.ExpandMer(matchedAcceptedNVMers[i], kMerSize);
                //matchedMers += kMerNV + "\t";   
                for (int b = 0; b < kMerSize; b++)
                    kMerAccSB[loc + b] = kMerNV[b];
                acceptedMatches++;
            }

            for (int i = 0; i < matchedRejectedMerLocs.Count; i++)
            {
                int loc = matchedRejectedMerLocs[i];
                for (int b = 0; b < kMerSize; b++)
                    markersRejSB[loc + b] = 'X';
                rejectedMatches++;
            }

            for (int i = 0; i < lcMerLocs.Count; i++)
            {
                int loc = lcMerLocs[i];
                for (int b = 0; b < lcSize; b++)
                    markersLCFSB[loc + b] = '#';
                lcMatches++;
            }

            string markersAcc = markersAccSB.ToString();
            string matchedAcc = kMerAccSB.ToString();
            string markersRej = markersRejSB.ToString();
            string markersLCF = markersLCFSB.ToString();

            int readLength = read.Length;
            int lengthWritten = 0;
            lock (matches)
            {
                matches.WriteLine(FN + ":");
                matches.WriteLine(header.ToString() + " +" + acceptedMatches + "/-" + rejectedMatches + "/#" + lcMatches + " " + fate);

                for (int i = 0; i < readLength; i += 100)
                {
                    string readFragment = read.ToString(i, Math.Min(100, readLength - lengthWritten));
                    string markersAccFragment = markersAcc.Substring(i, Math.Min(100, readLength - lengthWritten));
                    string matchedAccFragment = matchedAcc.Substring(i, Math.Min(100, readLength - lengthWritten));
                    string markersRejFragment = markersRej.Substring(i, Math.Min(100, readLength - lengthWritten));
                    string markersLCFFragment = markersLCF.Substring(i, Math.Min(100, readLength - lengthWritten));

                    matches.WriteLine(i.ToString("D6") + " " + readFragment);
                    if (markersAccFragment.Contains('^'))
                    {    
                        matches.WriteLine("       " + markersAccFragment.TrimEnd());
                        matches.WriteLine("       " + matchedAccFragment.TrimEnd());
                    }
                    if (markersRejFragment.Contains('X'))
                        matches.WriteLine("       " + markersRejFragment.TrimEnd());
                    if (markersLCFFragment.Contains('#'))
                        matches.WriteLine("       " + markersLCFFragment.TrimEnd());

                    lengthWritten += 100;
                }
            }
        }

        private static void CountMatchesForRead(Sequence read, List<MerHashSet> incFilters, List<MerHashSet> excFilters, List<MerHashSet> incFilterSeeds, List<MerHashSet> excFilterSeeds,
                                               MerDictionary<ulong>[] incFilterVariantsMatched, MerDictionary<ulong>[] excFilterVariantsMatched, Dictionary<ulong, long>[] incCommonUnmatched, Dictionary<ulong, long>[] excCommonUnmatched,
                                               int kMerSize, ref ulong[] merSet, ref bool[] merValid, out int NsFound,
                                               int[] incMatchesForRead, int[] excMatchesForRead, SortedSet<int>[] matchedAcceptedMersLocs, Dictionary<int, int>[] matchedAcceptedCoveredBases, List<ulong>[] matchedAcceptedNVMers,
                                               SortedSet<int>[] matchedRejectedMersLocs, Dictionary<int, int>[] matchedRejectedCoveredBases, List<ulong> kMerVariants, //)
                                               ref long thread_kMersChecked, ref long thread_kMersPassedSeedCheck, ref long thread_kMersVariantsTried, ref long thread_kMerVariantsFound, ref long thread_kMersNotMatchedAlready, ref long thread_kMersMatchedAlready)
        {
            NsFound = 0;
            Array.Clear(incMatchesForRead, 0, incMatchesForRead.Length);
            Array.Clear(excMatchesForRead, 0, excMatchesForRead.Length);

            int mersInRead = Sequence.GenerateMersFromRead(read, kMerSize, ref merSet, ref merValid);

            //if (merSet[0] == 0xBFCAFC011EEC2180)
            //    Debugger.Break();

            // match kMers against all the filters and remember where they matched
            for (int m = 0; m < mersInRead; m++)
            {
                if (merValid[m])
                {
                    MatchMer(merSet[m], kMerSize, incFilters, excFilters, incFilterSeeds, excFilterSeeds, incFilterVariantsMatched, excFilterVariantsMatched, incCommonUnmatched, excCommonUnmatched,
                             m, matchedAcceptedMersLocs, matchedAcceptedNVMers, matchedRejectedMersLocs, kMerVariants, //)
                             ref thread_kMersChecked, ref thread_kMersPassedSeedCheck, ref thread_kMersVariantsTried, ref thread_kMerVariantsFound, ref thread_kMersNotMatchedAlready, ref thread_kMersMatchedAlready);
                }
                else
                {
                    NsFound++;
                }
            } // all mers in read

            // convert matching locations to counts of covered bases (rejected first so it can feed into accepted)
            for (int f = 0; f < excFilters.Count; f++)
            {
                if (matchedRejectedMersLocs[f].Count > 0)
                {
                    int cbr = ConvertMatchesToCoveredBases(matchedRejectedMersLocs[f], kMerSize, read.Length, matchedRejectedCoveredBases[f]);
                    excMatchesForRead[f] = cbr;
                }
                else
                {
                    matchedRejectedCoveredBases[f].Clear();
                    excMatchesForRead[f] = 0;
                }
            }
            for (int f = 0; f < incFilters.Count; f++)
            {
                if (matchedAcceptedMersLocs[f].Count > 0)
                {
                    int cba = ConvertMatchesToCoveredBases(matchedAcceptedMersLocs[f], kMerSize, read.Length, matchedAcceptedCoveredBases[f]);
                    // poor kMer sets - such as those coming from rough assemblies - may have the same kMers marked as 'accept' and 'reject'
                    // reject trumps accept at the kMer level as well as at the read level - so covering accepted has to be aware of what's also being rejected
                    int bothRandA = RemoveAcceptedBasesAlsoRejected(matchedAcceptedCoveredBases[f], matchedRejectedCoveredBases);
                    incMatchesForRead[f] = cba - bothRandA;
                }
                else
                {
                    matchedAcceptedCoveredBases[f].Clear();
                    incMatchesForRead[f] = 0;
                }
            }
        }

        private static int RemoveAcceptedBasesAlsoRejected(Dictionary<int, int> matchedAcceptedCoveredBases, Dictionary<int, int>[] matchedRejectedCoveredBases)
        {
            int bothRandA = 0;
            for (int fr = 0; fr < matchedRejectedCoveredBases.Length; fr++)
                foreach (int rbi in matchedRejectedCoveredBases[fr].Keys)
                    if (matchedAcceptedCoveredBases.ContainsKey(rbi))
                        bothRandA++;

            return bothRandA;
        }

        private static int ConvertMatchesToCoveredBases(SortedSet<int> matchLocs, int kMerSize, int readLength, Dictionary<int, int> coveredBases)
        {
            coveredBases.Clear();
            int gaps = 0;
            int previousMatchLoc = -1;

            foreach (int matchLoc in matchLocs)
            {
                if (previousMatchLoc >= 0)
                    gaps += matchLoc - previousMatchLoc - 1;
                previousMatchLoc = matchLoc;
                for (int i = 0; i < kMerSize; i++)
                {
                    if (!coveredBases.ContainsKey(matchLoc + i))
                        coveredBases.Add(matchLoc + i, 0);
                    coveredBases[matchLoc + i]++;
                }
            }

            return coveredBases.Count - gaps;
        }


        private static void MatchMer(ulong mer, int kMerSize, List<MerHashSet> incFilters, List<MerHashSet> excFilters, List<MerHashSet> incFilterSeeds, List<MerHashSet> excFilterSeeds,
                                     MerDictionary<ulong>[] incFilterVariantMatched, MerDictionary<ulong>[] excFiltervariantMatches, Dictionary<ulong, long>[] incCommonUnmatched, Dictionary<ulong, long>[] excCommonUnmatched,
                                     int m, SortedSet<int>[] matchedAcceptedMersLocs, List<ulong>[] matchedAcceptedNVMers, SortedSet<int>[] matchedRejectedMersLocs, List<ulong> kMerVariants, //)
                                     ref long thread_kMersChecked, ref long thread_kMersPassedSeedCheck, ref long thread_kMersVariantsTried, ref long thread_kMerVariantsFound, ref long thread_kMersNotMatchedAlready, ref long thread_kMersMatchedAlready)
        {
            // get the canonical form of the current mer
            ulong canonicalMer = mer;
            ulong rcMer = kMers.ReverseComplement(mer, kMerSize);
            if (rcMer < mer)
                canonicalMer = rcMer;

            for (int f = 0; f < incFilters.Count; f++)
                MatchMerToFilter(m, mer, canonicalMer, kMerSize, incFilters[f], incFilterSeeds[f], incFilterVariantMatched[f], incCommonUnmatched[f], matchedAcceptedMersLocs[f], matchedAcceptedNVMers[f], kMerVariants, //);
                                 ref thread_kMersChecked, ref thread_kMersPassedSeedCheck, ref thread_kMersVariantsTried, ref thread_kMerVariantsFound, ref thread_kMersNotMatchedAlready, ref thread_kMersMatchedAlready);

            for (int f = 0; f < excFilters.Count; f++)
                if (excFilters[f] != null)
                    MatchMerToFilter(m, mer, canonicalMer, kMerSize, excFilters[f], excFilterSeeds[f], excFiltervariantMatches[f], excCommonUnmatched[f], matchedRejectedMersLocs[f], null, kMerVariants, //);
                                      ref thread_kMersChecked, ref thread_kMersPassedSeedCheck, ref thread_kMersVariantsTried, ref thread_kMerVariantsFound, ref thread_kMersNotMatchedAlready, ref thread_kMersMatchedAlready);
        }

        private static void MatchMerToFilter(int m, ulong kMer, ulong canonicalMer, int kMerSize, MerHashSet filter, MerHashSet seeds, MerDictionary<ulong> matchingVariant, Dictionary<ulong, long> commonUnmatched,
                                             SortedSet<int> matchedLocs, List<ulong> matchedMers, List<ulong> kMerVariants, //)
                                             ref long thread_kMersChecked, ref long thread_kMersPassedSeedCheck, ref long thread_kMersVariantsTried, ref long thread_kMerVariantsFound, ref long thread_kMersNotMatchedAlready, ref long thread_kMersMatchedAlready)
        {
            // first try for a exact match (against exact kMers)
            if (filter.Contains(canonicalMer))
            {
                matchedLocs.Add(m);
                if (matchedMers != null)
                    matchedMers.Add(kMer);
                return;
            }

            // have we looked for a variant of this kMer before?
            if (matchingVariant.ContainsKey(kMer))
            {
                matchedLocs.Add(m);
                thread_kMersMatchedAlready++;
                if (matchedMers != null)
                    matchedMers.Add(matchingVariant[kMer]);
                return;
            }

            // try for a new 1-sub match if requested
            if (seeds != null)
            {
                // check a seed match first and only go on to generate/check kMer variants if that succeeds
                // a single-base variant must have an exact seed match at the start (and only the low end bases are varied).
                thread_kMersChecked++;
                ulong topSeed = canonicalMer & seedMask;
                if (seeds.Contains(topSeed))
                {
                    thread_kMersPassedSeedCheck++;

                    // failed to find a variant this kMer before (most common failures only)
                    if (commonUnmatched.ContainsKey(canonicalMer))
                    {
                        commonUnmatched[canonicalMer]++;
                        thread_kMersNotMatchedAlready++;
                        return;
                    }

                    // new or uncommon, non-matched kMer - try looking for matching variants
                    thread_kMersVariantsTried++;
                    kMerVariants.Clear();
                    bool unmatched = true;
                    // generate post-seed variants only to reduce variant space
                    kMers.GenerateMerSubVariants(kMer, kMerVariants, kMerSeedSize, kMerSize);
                    foreach (ulong kMerVariant in kMerVariants)
                    {
                        ulong canonicalVariant = kMerVariant;
                        ulong kMerVariantRC = kMers.ReverseComplement(kMerVariant, kMerSize);
                        if (kMerVariantRC < kMerVariant)
                            canonicalVariant = kMerVariantRC;

                        if (filter.Contains(canonicalVariant))
                        {
                            matchedLocs.Add(m);
                            if (matchedMers != null)
                                matchedMers.Add(kMerVariant);
                            matchingVariant.AddIfNotPresent(kMer, kMerVariant);
                            thread_kMerVariantsFound++;
                            unmatched = false;
                            break;
                        }
                    } // check each variant

                    // didn't match the kMer or a variant, remember not to try this again
                    if (unmatched)
                        commonUnmatched.Add(canonicalMer, 1);
                } // seed matched
            }
            
        }

        static void RateReporter()
        {
            DateTime lastTimeAwake = DateTime.Now;
            long lastReadsCount = 0;

            while (true)
            {
                signalReporter.WaitOne(reportInterval);
                if (stopReporter)
                    break;

                DateTime timeNow = DateTime.Now;
                double timeTaken = (timeNow - lastTimeAwake).TotalSeconds;
                lastTimeAwake = timeNow;
                long currentReadsCount = progressReadsRead;
                long readsInTime = currentReadsCount - lastReadsCount;
                lastReadsCount = currentReadsCount;
                int readsRate = (int)((double)readsInTime / timeTaken);

                Console.WriteLine("filtered +" + progressReadsAccepted + ",-" + progressReadsRejected + " from " + currentReadsCount + " sequences at " + readsRate + " rps");
            }
        }

        private static void DumpMatches(List<ulong> matches, int kMerSize)
        {
            foreach (ulong match in matches)
                Console.Write(kMers.ExpandMer(match, kMerSize) + "\t");
            Console.WriteLine();
        }
    }

    public class readerThreadParams
    {
        public List<MerHashSet> incFilters;
        public List<MerHashSet> incFiltersAsRead;
        public List<int> incFilterMins;
        public List<bool> incFilterPct;
        public List<MerHashSet> incFilterSeeds;
        public List<MerHashSet> excFilters;
        public List<int> excFilterMins;
        public List<bool> excFilterPct;
        public List<MerHashSet> excFilterSeeds;
        public int kMerSize;
        public int minLen;
        public BufferedReader[] bufferedReads;
        public int wantedAcceptedReads;
        public int fileFormat;
        public int outputFormat;
        public int minQual;
        public int qualOffset;
        public string[] readsDisplayFNs;
        public BufferedWriter[] filteredReads;
        public BufferedWriter[] discardedReads;
        public long acceptedReads;
        public long rejectedReads;
        public long writtenReads;
        public long skippedReadsShort;
        public long basesQualTrimmed;
        public long noOfReads;
    }

}

